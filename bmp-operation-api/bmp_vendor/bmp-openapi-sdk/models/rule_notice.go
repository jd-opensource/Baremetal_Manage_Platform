// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RuleNotice 通知策略
//
// swagger:model RuleNotice
type RuleNotice struct {

	// 有效时段结束时间 ["23:59:59"]
	// Required: true
	EffectiveIntervalEnd *string `json:"effectiveIntervalEnd"`

	// 有效时段开始时间 ["00:00:00"]
	// Required: true
	EffectiveIntervalStart *string `json:"effectiveIntervalStart"`

	// 通知条件，可多选 [1表示报警， 2表示恢复正常]
	// Required: true
	NoticeCondition []int64 `json:"noticeCondition"`

	// 通知周期(分钟) [5 10 15 30 60 180 360 720 1440]
	// Required: true
	NoticePeriod *int64 `json:"noticePeriod"`

	// 接收渠道，可多选 [1表示站内信， 2表示邮件]
	// Required: true
	NoticeWay []int64 `json:"noticeWay"`

	// 通知对象用户Id
	// Required: true
	UserID *string `json:"userId"`

	// 通知对象用户
	UserName string `json:"userName,omitempty"`
}

// Validate validates this rule notice
func (m *RuleNotice) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEffectiveIntervalEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEffectiveIntervalStart(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNoticeCondition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNoticePeriod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNoticeWay(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RuleNotice) validateEffectiveIntervalEnd(formats strfmt.Registry) error {

	if err := validate.Required("effectiveIntervalEnd", "body", m.EffectiveIntervalEnd); err != nil {
		return err
	}

	return nil
}

func (m *RuleNotice) validateEffectiveIntervalStart(formats strfmt.Registry) error {

	if err := validate.Required("effectiveIntervalStart", "body", m.EffectiveIntervalStart); err != nil {
		return err
	}

	return nil
}

func (m *RuleNotice) validateNoticeCondition(formats strfmt.Registry) error {

	if err := validate.Required("noticeCondition", "body", m.NoticeCondition); err != nil {
		return err
	}

	return nil
}

func (m *RuleNotice) validateNoticePeriod(formats strfmt.Registry) error {

	if err := validate.Required("noticePeriod", "body", m.NoticePeriod); err != nil {
		return err
	}

	return nil
}

func (m *RuleNotice) validateNoticeWay(formats strfmt.Registry) error {

	if err := validate.Required("noticeWay", "body", m.NoticeWay); err != nil {
		return err
	}

	return nil
}

func (m *RuleNotice) validateUserID(formats strfmt.Registry) error {

	if err := validate.Required("userId", "body", m.UserID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this rule notice based on context it is used
func (m *RuleNotice) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *RuleNotice) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RuleNotice) UnmarshalBinary(b []byte) error {
	var res RuleNotice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
